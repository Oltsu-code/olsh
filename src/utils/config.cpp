#include "utils/config.h"
#include <fstream>
#include <iostream>
#include <sstream>

#ifdef _WIN32
#include <windows.h>
#include <shlobj.h>
#else
#include <unistd.h>
#include <pwd.h>
#endif

namespace olsh::Utils {

Config::Config() {
    std::string configDir = getConfigDirectory();
    configFilePath = std::filesystem::path(configDir) / ".olshell" / "config.yaml";
    
    // default values
    settings["prompt"] = "┌─({user}@{hostname})-[{cwd}]\n└─$ ";
    
    ensureConfigDirectoryExists();

    // try loading existing config
    if (!loadConfig()) {
        createDefaultConfig();
        saveConfig();
    }
}

std::string Config::getConfigDirectory() {
#ifdef _WIN32
    char path[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, path))) {
        return std::string(path);
    }
    return "C:\\";
#else
    const char* home = getenv("HOME");
    if (home) {
        return std::string(home);
    }
    
    struct passwd* pw = getpwuid(getuid());
    if (pw && pw->pw_dir) {
        return std::string(pw->pw_dir);
    }
    
    return "/";
#endif
}

void Config::ensureConfigDirectoryExists() {
    std::filesystem::path configDir = configFilePath.parent_path();
    if (!std::filesystem::exists(configDir)) {
        try {
            std::filesystem::create_directories(configDir);
        } catch (const std::filesystem::filesystem_error& e) {
            std::cerr << "Failed to create config directory: " << e.what() << std::endl;
        }
    }
}

void Config::createDefaultConfig() {
    settings.clear();
    settings["prompt"] = "┌─({user}@{hostname})-[{cwd}]\n└─$ ";
    settings["shell_name"] = "OlShell";
    settings["version"] = "0.1.0-alpha";
    settings["welcome_message"] = "OlShell v2.0 - Best shell ever made yk. Pls delete bash, zsh and every other shell u have on ur computer to use this.";
}

bool Config::loadConfig() {
    if (!std::filesystem::exists(configFilePath)) {
        return false;
    }
    
    std::ifstream file(configFilePath);
    if (!file.is_open()) {
        return false;
    }
    
    std::string line;
    while (std::getline(file, line)) {
        // skip empty lines and comments
        if (line.empty() || line[0] == '#') {
            continue;
        }
        
        // parsing (simple for now)
        size_t colonPos = line.find(':');
        if (colonPos != std::string::npos) {
            std::string key = line.substr(0, colonPos);
            std::string value = line.substr(colonPos + 1);
            
            // delete white space
            key.erase(0, key.find_first_not_of(" \\t"));
            key.erase(key.find_last_not_of(" \\t") + 1);
            value.erase(0, value.find_first_not_of(" \\t"));
            value.erase(value.find_last_not_of(" \\t") + 1);
            
            // remove quotes
            if (value.size() >= 2 && value.front() == '"' && value.back() == '"') {
                value = value.substr(1, value.size() - 2);
            }

            // handle escape sequences
            if (key == "prompt") {
                std::string unescaped;
                for (size_t i = 0; i < value.size(); ++i) {
                    if (value[i] == '\\' && i + 1 < value.size()) {
                        switch (value[i + 1]) {
                            case 'n': unescaped += '\n'; ++i; break;
                            case 't': unescaped += '\t'; ++i; break;
                            case '\\': unescaped += '\\'; ++i; break;
                            default: unescaped += value[i]; break;
                        }
                    } else {
                        unescaped += value[i];
                    }
                }
                value = unescaped;
            }
            
            settings[key] = value;
        }
    }
    
    return true;
}

bool Config::saveConfig() {
    std::ofstream file(configFilePath);
    if (!file.is_open()) {
        return false;
    }
    
    file << "# OlShell Configuration File\n";
    file << "# This file is automatically generated\n\n";
    
    for (const auto& [key, value] : settings) {
        std::string escapedValue = value;

        if (key == "prompt") {
            std::string escaped;
            for (char c : value) {
                switch (c) {
                    case '\n': escaped += "\\n"; break;
                    case '\t': escaped += "\\t"; break;
                    case '\\': escaped += "\\\\"; break;
                    default: escaped += c; break;
                }
            }
            escapedValue = escaped;
        }
        
        file << key << ": \"" << escapedValue << "\"\n";
    }
    
    return true;
}

std::string Config::getSetting(const std::string& key, const std::string& defaultValue) const {
    auto it = settings.find(key);
    if (it != settings.end()) {
        return it->second;
    }
    return defaultValue;
}

void Config::setSetting(const std::string& key, const std::string& value) {
    settings[key] = value;
}

std::string Config::getPrompt() const {
    return getSetting("prompt", "$ ");
}

void Config::setPrompt(const std::string& prompt) {
    setSetting("prompt", prompt);
}

bool Config::configExists() const {
    return std::filesystem::exists(configFilePath);
}

} // namespace olsh::Utils

